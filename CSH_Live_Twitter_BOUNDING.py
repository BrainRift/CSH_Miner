import json
import os
import sqlite3 as lite
import sys
import urllib.request
import tweepy
from Twitter_Keys import *
from Twitter_settings import *
import hashlib
from Twitter_validate import dump_hash


auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
#auth = tweepy.Stream(consumer_key, consumer_secret, access_token, access_token_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth, wait_on_rate_limit=True)

#bounding_box_to_search = [-82.265659,41.373736,-82.164579,41.426754] # Amherst, Ohio -- box is official twitter
#bounding_box_to_search = [-81.877771,41.392684,-81.533163,41.599195] # Cleveland, Ohio -- official Twitter box
#bounding_box_to_search = [-81.892219,41.372914,-81.639142,41.546592] # Cleveland, Ohio -- box is one I generated by picking spots on map
#bounding_box_to_search = [-84.175873,40.685511,-84.030991,40.788007] # Lima Ohio
#bounding_box_to_search = [-0.132115,51.498521,-0.119283,51.502969] # Parliment - London UK -- Custom

#bounding_box_to_search = [-84.545288,39.098020,-84.495163,39.124126] 

#bounding_box_to_search = [-83.2,39.90,-82.9,40.1] # Columbus, Ohio

bounding_box_to_search = BOUNDING_BOX #Pulling data from Twitter_settings.py



#print(api.rate_limit_status())

casename = CASE_NAME

dbname = casename + ".db"

conn = lite.connect(dbname)  # Adjust this later to store each case in it's own DB

c = conn.cursor()

c.execute('''
    CREATE TABLE IF NOT EXISTS T_Live_Geo(
                                        tweet_id INTEGER NOT NULL PRIMARY KEY, 
                                        screen_name TEXT, 
                                        user_id INTEGER,
                                        users_name TEXT, 
                                        created_at TEXT, 
                                        created_date_UTC DATETIME,
                                        is_retweet TEXT,
                                        text TEXT,
                                        place_name TEXT,
                                        country_code TEXT,
                                        country TEXT,
                                        bounding_box TEXT,
                                        source_tweeted TEXT, 
                                        geo TEXT,
                                        in_reply_to_user TEXT,
                                        inreply_statusid TEXT, 
                                        posted_image_dest TEXT,
                                        tweeted_image BLOB,
                                        image_hash TEXT,
                                        media_type TEXT, 
                                        media_url TEXT,
                                        media_id TEXT, 
                                        posted_video_dest TEXT,
                                        tweeted_video BLOB, 
                                        video_hash TEXT,
                                        video_type TEXT, 
                                        video_url TEXT,
                                        url_in_tweet TEXT,
                                        coordinates TEXT, 
                                        bounding_box_searched TEXT, 
                                        result_bounding_box TEXT, 
                                        status BLOB, 
                                        status_hash TEXT, 
                                        bookmark TEXT)''')

conn.commit()
        


class CSHlistener(tweepy.Stream):    
    
    def on_status(self, status): # This Filters out the "state" overlaping bounding box, but other overlaping areas may exist (other towns)
        
        global bounding_box_to_search
        
        if status.place.place_type != 'admin':
            
            #Prints basic information to screen
            print(" ")
            print("--------------------------")
            print(" ")
            print("Date : ", status.created_at)
            print("Username : ", status.user.screen_name)
            print("Name : ", status.user.name)
            print("Location : ", status.place.full_name)
            print("Bounding : ", status.place.bounding_box.coordinates)
            text_display = status.text
            print("Tweet : ", text_display.replace('&amp;','&'))
            print(" ")
            
            
            #Puts the data in the database
            #if status.retweeted:
            #   return
            
            tweetid = status.id
            geo = status.geo
            coords = status.coordinates
            re_tweet = status.retweeted
            screenname = status.user.screen_name
            userid = status.user.id
            createdat = status.timestamp_ms
            createddate = status.created_at
            usersname = status.user.name
            
            if hasattr(status, 'retweeted_status'):
                is_retweet = True
            else:
                is_retweet = False            
        
            Amp_text = status.text
            tweet = Amp_text.replace('&amp;','&') 
            
            if status.place is not None:
                placename = status.place.full_name
                countrycode = status.place.country_code
                country = status.place.country
                boundingbox = str(status.place.bounding_box.coordinates)
    
            else:
                placename = None
                countrycode = None
                country = None
                boundingbox = None            
            
            source = status.source
            replystatusid = status.in_reply_to_status_id
            reply_to_screen_name = status.in_reply_to_screen_name
            bounding_box_searched = str(bounding_box_to_search)
            result_bounding_box = str(status.place.bounding_box.coordinates)
            
            #New media section
            #Checks for Media in the Tweet and downloads it
            
            if 'media' in status.entities:
                image_posted = status.entities['media'][0]['media_url']
                
                remove_media_url = image_posted.split('/')[-1]
                posted_image_dest = os.path.join("Case_Attachments/" + casename + "/bounding_search/images/" + screenname + "---" + remove_media_url)
                image_path = "Case_Attachments/" + casename + "/bounding_search/images/"                
                
                
                
                if not os.path.exists(image_path):
                    os.makedirs(image_path)
                
                #urllib.request.urlretrieve(image_posted, filename = posted_image_dest)
                
                # This will try to pull the media.  If an error occurs, it will note it in the DB destination column
                
                try:
                    print("Downloading Image... %s" % posted_image_dest)
                    urllib.request.urlretrieve(image_posted, filename = posted_image_dest)
                    
                    tweeted_image = open(posted_image_dest, "rb").read()
                    
                    image_hash = dump_hash(tweeted_image)
            
                except urllib.error.URLError as e:
                    posted_image_dest = "ERROR DOWNLOADING FILE"
                    tweeted_image = None
                    image_hash = None                    
                    pass 
                
                except:
                    posted_image_dest = "ERROR DOWNLOADING FILE"
                    tweeted_image = None
                    image_hash = None                    
                    pass                    
                    
                
                mediatype = status.entities['media'][0]['type']
                mediaurl = status.entities['media'][0]['media_url']
                mediaid = status.entities['media'][0]['id']        
                
            else:
                posted_image_dest = None
                mediatype = None
                mediaurl = None
                mediaid = None
                tweeted_image = None
                image_hash = None
                
            #End new media section          
            
                
            # New Video Code Section
            #Checks for Video in the tweets and downloads it
            
            if hasattr(status, 'extended_entities'):
                if 'video_info' in status.extended_entities['media'][0]:
                    
                    # This section checks the number of dictionaries are in the variants
                    # It then looks at the bitrate of the variants and determines the highest value
                    # Once the highest value is determined, it extracts that video.
                    
                    variant_times = len(status.extended_entities['media'][0]['video_info']['variants']) # Gets the number of variants
                    
                    bit_rate = -1
                    
                    for variant_count in range(0, variant_times): #iterates through all the variants in that tweets
                        
                        
                        if 'bitrate' in status.extended_entities['media'][0]['video_info']['variants'][variant_count] and \
                           bit_rate < status.extended_entities['media'][0]['video_info']['variants'][variant_count]['bitrate']:
                            bit_rate = status.extended_entities['media'][0]['video_info']['variants'][variant_count]['bitrate']
                            videourl = status.extended_entities['media'][0]['video_info']['variants'][variant_count]['url']
                            videotype = status.extended_entities['media'][0]['video_info']['variants'][variant_count]['content_type']
        
                    remove_video_url = videourl.split('/')[-1]
                    posted_video_dest = os.path.join("Case_Attachments/" + casename + "/bounding_search/videos/" + screenname + "---" + remove_video_url)
                    video_path = "Case_Attachments/" + casename + "/bounding_search/videos/"
                    
                    if not os.path.exists(video_path):
                        os.makedirs(video_path)
                
                    #urllib.request.urlretrieve(videourl, filename = posted_video_dest)
                    
                    try:
                        print("Downloading Video... %s" % posted_video_dest)
                        urllib.request.urlretrieve(videourl, filename = posted_video_dest)
                        
                        tweeted_video = open(posted_video_dest, "rb").read()
                    
                        video_hash = dump_hash(tweeted_video)                        
                
                    except urllib.error.URLError as e:
                        posted_video_dest = "ERROR DOWNLOADING FILE"
                        pass                    
                    
                else:
                    posted_video_dest = None
                    videotype= None
                    videourl= None 
                    tweeted_video = None
                    video_hash = None
            else:
                posted_video_dest = None
                videotype= None
                videourl= None
                tweeted_video = None
                video_hash = None                
            
            # End Video Check
            
            if not status.entities['urls']:
                url_in_tweet = None
    
            else:
                url_in_tweet = str(status.entities['urls'][0]['url'])            
    
            if geo is not None:
                geo = json.dumps(geo)
    
            if coords is not None:
                coords = json.dumps(coords)
                
            bookmark = None
            
            status_encode = str(status).encode('utf-8')
            
            status_hash = dump_hash(status_encode)
    
            
            try:
                c.execute('''INSERT INTO T_Live_Geo (
                        tweet_id, 
                        screen_name, 
                        user_id, 
                        users_name, 
                        created_at, 
                        created_date_UTC,
                        is_retweet,
                        text,
                        place_name,
                        country_code,
                        country,
                        bounding_box,
                        source_tweeted, 
                        geo,
                        in_reply_to_user,
                        inreply_statusid,
                        posted_image_dest,
                        tweeted_image,
                        image_hash,
                        media_type, 
                        media_url, 
                        media_id,
                        posted_video_dest,
                        tweeted_video, 
                        video_hash,
                        video_type,
                        video_url,
                        url_in_tweet,
                        coordinates, 
                        bounding_box_searched,
                        result_bounding_box,
                        status,
                        status_hash,
                        bookmark)
                        VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)''' , 
                            (tweetid, 
                             screenname, 
                             userid, 
                             usersname, 
                             createdat, 
                             createddate,
                             is_retweet,
                             tweet,
                             placename,
                             countrycode,
                             country,
                             boundingbox,
                             source,
                             geo,  
                             reply_to_screen_name,
                             replystatusid,
                             posted_image_dest,
                             tweeted_image,
                             image_hash,
                             mediatype, 
                             mediaurl, 
                             mediaid, 
                             posted_video_dest,
                             tweeted_video,
                             video_hash,
                             videotype, 
                             videourl,
                             url_in_tweet,
                             coords, 
                             bounding_box_searched, 
                             result_bounding_box, 
                             str(status), 
                             status_hash, 
                             bookmark))
                
                conn.commit()
                #print(str(createddate), screenname, str(tweet))
                       
            except lite.IntegrityError:
                print(str(tweetid), "--- Record already Exists")            
            
            
            
    def on_error(self, status_code):
        print("Twitter encountered and error.")
        print("Twitter error code : ", status_code)
        print("Stream will resume automatically..")
        print("Please wait...")
        print(" ") 
        return True # Don't kill the stream

    def on_timeout(self):
        print(sys.stderr, 'Timeout...')
        return True # Don't kill the stream
    
   
csh = CSHlistener(consumer_key,consumer_secret,access_token,access_token_secret)


#csh.filter(locations = bounding_box_to_search) # Can not filter location & keywords. Columbus, OH
csh.filter(locations=bounding_box_to_search)
# Random box around Cleveland locations=[-81.892219,41.372914,-81.639142,41.546592]

#40.716852389456534, -74.14088365351354   40.662743127513465, -74.19716801659628